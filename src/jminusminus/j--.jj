// Copyright 2011 Bill Campbell, Swami Iyer and Bahar Akbal-Delibas

// This is the input file to JavaCC for generating a scanner and 
// a parser for j--. From the specification in this file, JavaCC,  
// among other files, generates a JavaCCParser.java file 
// under $j/j--/src/jminusminus. This file is the parser. The code 
// between  PARSER_BEGIN( JavaCCParser ) and 
// PARSER_END( JavaCCParser ) is copied verbatim to this file. JavaCC 
// also generates a JavaCCParserTokenManager.java file which is the 
// scanner.

PARSER_BEGIN( JavaCCParser )

package jminusminus;

import java.util.ArrayList;

/**
 * Parser generated by JavaCC. It parses a j-- compilation unit 
 * (program file), taking tokens from the scanner (also generated by 
 * JavaCC), and produces an abstract syntax tree (AST) for it.
 */

class JavaCCParser {
    /** Whether a parser error has been found. */
    private boolean errorHasOccurred;
        
    /** Name of the file that is parsed. */     
    private String fileName;
        
    /**
     * Pull out the ambiguous part of a name and return it. 
     * 
     * @param name with an ambiguos part (possibly).
     * @return ambiguous part or null.
     */
    
    private AmbiguousName ambiguousPart( TypeName name ) {
        String qualifiedName = name.toString();
        int lastDotIndex = qualifiedName.lastIndexOf( '.' );
        return lastDotIndex == -1
            ? null // It was a simple name
            : new AmbiguousName( name.line(),
                qualifiedName.substring( 0, lastDotIndex ) );
    }

    /**
     * Report a syntax error.
     * 
     * @param message message identifying the error.
     * @param args related values.
     */

    private void reportParserError( String message, Object... args ) {
        errorHasOccurred = true;
        System.err.printf( "%s:%d: ", fileName, token.beginLine );
        System.err.printf( message, args );
        System.err.println();
    }
        
    /**
     * Recover from the parser error that occurred by skipping to 
     * any of the specified tokens. 
     *
     * Current error recovery mechanism is rather simple-minded and is 
     * based on skipping all the tokens until a SEMI or an EOF is 
     * encountered. This scheme can be enhanced by passing in the 
     * FOLLOW-SET of the non-terminal at hand.
     * 
     * @param skipTo array of tokens that we could skip to.
     * @param e exception that is raised by JavaCC in the event 
     * of a parser error.
     */
         
    private void recoverFromError( int[] skipTo, ParseException e ) {   
        // Get the possible expected tokens
        StringBuffer expected = new StringBuffer();
        for ( int i = 0; i < e.expectedTokenSequences.length; i++ ) {
            for ( int j = 0; j < e.expectedTokenSequences[ i ].length; 
                j++ ) {
                expected.append( "\n" );
                expected.append( "    " );
                expected.append( tokenImage[ 
                    e.expectedTokenSequences[ i ][ j ] ] );
                expected.append( "..." );
            }    
        }    

        // Print error message
        if ( e.expectedTokenSequences.length == 1 ) {
            reportParserError( "\"%s\" found where %s sought", 
                getToken( 1 ), expected );
        }
        else {
            reportParserError( "\"%s\" found where one of %s sought", 
                getToken( 1 ), expected );
        }

        // Recover
        boolean loop = true;              
        do {
            token = getNextToken(); 
            for ( int i = 0; i < skipTo.length; i++ ) {
                if ( token.kind == skipTo[ i ] ) {
                    loop = false;
                    break;
                }
            }
        } while( loop );
    }   

    /** 
     * Set the name of the file that is being parsed. 
     *
     * @param fileName name of the file.
     */
         
    public void fileName( String fileName ) {               
        this.fileName = fileName;
    }

    /**
     * Has a parser error occurred up to now?
     * 
     * @return true or false.
     */

    public boolean errorHasOccurred() {
        return errorHasOccurred;
    }   
}

PARSER_END( JavaCCParser )

/////////////////////////////////////////////////////////
//         The j-- lexical grammar starts here         //
/////////////////////////////////////////////////////////

// Whitespace -- ignored
SKIP: {" "|"\t"|"\n"|"\r"|"\f"}

// Single line comment -- ignored
SKIP: {<SINGLE_LINE_COMMENT: "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>}

// Reserved words
TOKEN:
{
  < ABSTRACT: "abstract" >
| < BOOLEAN: "boolean" >
| < CHAR: "char" >
| < CLASS: "class" >
| < ELSE: "else" >
| < EXTENDS: "extends" >
| < FALSE: "false" >
| < IF: "if" >
| < IMPORT: "import" >
| < INSTANCEOF: "instanceof" >
| < INT: "int" >
| < NEW: "new" >
| < NULL: "null" >
| < PACKAGE: "package">
| < PRIVATE: "private" >
| < PROTECTED: "protected" >
| < PUBLIC: "public" >
| < RETURN: "return" >
| < STATIC: "static" >
| < SUPER: "super" >
| < THIS: "this" >
| < TRUE: "true" >
| < VOID: "void" >
| < WHILE: "while" >
}

// Operators (these could be combined with the reserved words)
TOKEN:
{
  < PLUS: "+" >
| < ASSIGN: "=" >
| < DEC: "--" >
| < EQUAL: "==" >
| < GT: ">" >
| < INC: "++" >
| < LAND: "&&" >
| < LE: "<=" >
| < LNOT: "!" >
| < MINUS: "-" >
| < PLUS_ASSIGN: "+=" >
| < STAR: "*" >
}

// Separators (these could be combined with the reserved words)
TOKEN:
{
  < LPAREN: "(" >
| < RPAREN: ")" >
| < LCURLY: "{" >
| < RCURLY: "}" >
| < LBRACK: "[" >
| < RBRACK: "]" >
| < SEMI: ";" >
| < COMMA: "," >
| < DOT: "." >
}

// Identifiers
TOKEN:
{
  < IDENTIFIER: (<LETTER>|"_"|"$") (<LETTER>|<DIGIT>|"_"|"$")* >
| < #LETTER: ["a"-"z","A"-"Z"] >
| < #DIGIT: ["0"-"9"] >
| < #NON_ZERO_DIGIT: ["1"-"9"] >
}

// Literals
TOKEN:
{
  < INT_LITERAL: ("0" | <NON_ZERO_DIGIT> (<DIGIT>)*) >
| < CHAR_LITERAL: "'" (<ESC> | ~["'","\\","\n","\r"]) "'" >
| < STRING_LITERAL: "\"" (<ESC> | ~["\"","\\","\n","\r"])* "\"" >   
| < #ESC: "\\" ["n","t","b","r","f","\\","'","\""] >
}

// For anything else, we return an ERROR token. Without this 
// definition the TokenManager will throw an Error when a lexical 
// error occurs, making it impossible to recover from it. So we 
// define this ERROR token. 
TOKEN:
{
 < ERROR: ~[] >
}

/////////////////////////////////////////////////////////
//       The j-- syntactic grammar starts here         //
/////////////////////////////////////////////////////////

/**
 * Parse a compilation unit (a program file) and construct an AST 
 * for it. After constructing the Parser, this is its entry point.
 * 
 * <pre>
 *   compilationUnit ::= [PACKAGE qualifiedIdentifier SEMI]
 *                       {IMPORT  qualifiedIdentifier SEMI}
 *                       {typeDeclaration}
 *                       EOF 
 * </pre>
 * 
 * @return an AST for a compilationUnit.
 */

public JCompilationUnit compilationUnit(): {
    int line = 0;
    TypeName packageName = null; // Default
    TypeName anImport = null;
    ArrayList<TypeName> imports = 
        new ArrayList<TypeName>();
    JAST aTypeDeclaration = null;
    ArrayList<JAST> typeDeclarations = new ArrayList<JAST>();
}
{
    try {
        [ 
            <PACKAGE> { line = token.beginLine; }
            packageName = qualifiedIdentifier() 
            <SEMI> 
        ]
        (
            <IMPORT> { line = line == 0 ? token.beginLine : line; }
            anImport = qualifiedIdentifier() 
            { imports.add( anImport ); } 
            <SEMI>
        )*
        (
            aTypeDeclaration = typeDeclaration()
            {
                line = line == 0 ? aTypeDeclaration.line() : line;
                typeDeclarations.add( aTypeDeclaration );
            }
        )*
        <EOF> { line = line == 0 ? token.beginLine : line; }
    } 
    catch ( ParseException e ) {
        recoverFromError( new int[] { SEMI, EOF }, e );
    }
    { 
        return new JCompilationUnit( fileName, line, 
            packageName, imports, typeDeclarations ); 
    }
}

/**
 * Parse a qualified identifier.
 * 
 * <pre>
 *   qualifiedIdentifier ::= IDENTIFIER {DOT IDENTIFIER}
 * </pre>
 * 
 * @return an instance of TypeName.
 */

private TypeName qualifiedIdentifier(): {
    int line = 0;
    String qualifiedIdentifier = "";
}
{
    try {
        <IDENTIFIER> 
        { 
            line = token.beginLine; 
            qualifiedIdentifier = token.image; 
        }
        ( 
            <DOT> <IDENTIFIER> 
            { qualifiedIdentifier += "." + token.image; } 
        )*
    } 
    catch ( ParseException e ) { 
        recoverFromError( new int[] { SEMI, EOF }, e ); 
    }
    { return 
         new TypeName( line, qualifiedIdentifier ); }
}

/**
 * Parse a type declaration.
 * 
 * <pre>
 *   typeDeclaration ::= modifiers classDeclaration
 * </pre>
 * 
 * @return an AST for a typeDeclaration.
 */

private JAST typeDeclaration(): {
    ArrayList<String> mods = null;
    JAST classDeclaration = null;
}
{
    try {
        mods = modifiers()
        classDeclaration = classDeclaration( mods )
    } 
    catch ( ParseException e ) { 
        recoverFromError( new int[] { SEMI, EOF }, e ); 
    }
    { return classDeclaration; }
}

/**
 * Parse modifiers.
 * 
 * <pre>
 *   modifiers ::= {PUBLIC | PROTECTED | PRIVATE | STATIC | ABSTRACT}
 * </pre>
 * 
 * Check for duplicates, and conflicts among access modifiers (public,
 * protected, and private). Otherwise, no checks.
 * 
 * @return a list of modifiers.
 */

private ArrayList<String> modifiers(): {
    ArrayList<String> mods = new ArrayList<String>();
    boolean scannedPUBLIC = false;
    boolean scannedPROTECTED = false;
    boolean scannedPRIVATE = false;
    boolean scannedSTATIC = false;
    boolean scannedABSTRACT = false;
}
{
    try {
    (   
        <PUBLIC> 
        { 
            mods.add( "public" );
            if ( scannedPUBLIC ) {
                reportParserError( "Repeated modifier: public" );
            }
            if ( scannedPROTECTED || scannedPRIVATE ) {
                reportParserError( "Access conflict in modifiers" );
            }
            scannedPUBLIC = true;
        } |
        <PROTECTED> 
        { 
            mods.add( "protected" );
            if ( scannedPROTECTED ) {
                reportParserError( "Repeated modifier: protected" );
            }
            if ( scannedPUBLIC || scannedPRIVATE ) {
                reportParserError( "Access conflict in modifiers" );
            }
            scannedPROTECTED = true;
        } |
        <PRIVATE> 
        { 
            mods.add( "private" );
            if ( scannedPRIVATE ) {
                reportParserError( "Repeated modifier: private" );
            }
            if ( scannedPUBLIC || scannedPROTECTED ) {
                reportParserError( "Access conflict in modifiers" );
            }
            scannedPRIVATE = true;
        } |
        <STATIC> 
        { 
            mods.add( "static" );
            if ( scannedSTATIC ) {
                reportParserError( "Repeated modifier: static" );
            }
            scannedSTATIC = true;
        } |
        <ABSTRACT> 
        { 
            mods.add( "abstract" );
            if ( scannedABSTRACT ) {
                reportParserError( "Repeated modifier: abstract" );
            }
            scannedABSTRACT = true;
        } 
    )*                  
    } 
    catch ( ParseException e ) { 
        recoverFromError( new int[] { SEMI, EOF }, e ); 
    }
    { return mods; }
}

/**
 * Parse a class declaration.
 * 
 * <pre>
 *   classDeclaration ::= CLASS IDENTIFIER 
 *                        [EXTENDS qualifiedIdentifier] 
 *                        classBody
 * </pre>
 * 
 * A class which doesn't explicitly extend another (super) class 
 * implicitly extends the superclass java.lang.Object.
 * 
 * @param mods the class modifiers.
 * @return an AST for a classDeclaration.
 */
     
private JClassDeclaration classDeclaration( ArrayList<String> mods ): {
    int line = 0;
    String name = "";
    Type superClass = Type.OBJECT;
    ArrayList<JMember> classBody = null;
}
{
    try {
        <CLASS> { line = token.beginLine; }
        <IDENTIFIER> { name = token.image; }
        [ 
            <EXTENDS> superClass = qualifiedIdentifier() 
        ]
        classBody = classBody()           
    } 
    catch ( ParseException e ) { 
        recoverFromError( new int[] { SEMI, EOF }, e ); 
    }
    { 
        return new JClassDeclaration( line, mods, 
            name, superClass, classBody ); 
    }
}

/**
 * Parse a class body.
 * 
 * <pre>
 *   classBody ::= LCURLY
 *                   {modifiers memberDecl}
 *                 RCURLY
 * </pre>
 * 
 * @return list of members in the class body.
 */

private ArrayList<JMember> classBody(): {
    ArrayList<String> mods = null;
    JMember aMember = null;
    ArrayList<JMember> members = new ArrayList<JMember>();
}
{
    try {
        <LCURLY>
        ( 
            mods = modifiers()
            aMember = memberDecl( mods ) { members.add( aMember ); } 
        )*
        <RCURLY>
    } 
    catch ( ParseException e ) { 
        recoverFromError( new int[] { SEMI, EOF }, e ); 
    }
    { return members; }
}

/**
 * Parse a member declaration.
 * 
 * <pre>
 *   memberDecl ::= IDENTIFIER            // constructor
 *                    formalParameters
 *                    block
 *                | (VOID | type) IDENTIFIER  // method
 *                    formalParameters
 *                    (block | SEMI)
 *                | type variableDeclarators SEMI 
 * </pre>
 * 
 * @param mods the class member modifiers.
 * @return an AST for a memberDecl.
 */
    
private JMember memberDecl( ArrayList<String>  mods ): {
    int line = 0;
    Type type = null;
    String name = "";
    ArrayList<JFormalParameter> params = null;
    JBlock body = null;
    ArrayList<JVariableDeclarator> variableDeclarators = null;
    JMember memberDecl = null;
}
{
    try {
        LOOKAHEAD( <IDENTIFIER> <LPAREN> )
        (
            <IDENTIFIER> 
            { 
                line = token.beginLine; 
                name = token.image; 
            } 
            params = formalParameters() 
            body = block()
            { 
                memberDecl = 
                new JConstructorDeclaration( line, mods, 
                                             name, params, body );
            }
        ) |     
        LOOKAHEAD( ( <VOID> | type() ) <IDENTIFIER> <LPAREN> )
        (
            ( 
                <VOID> { type = Type.VOID; } | 
                type = type() 
            ) 
            { line = token.beginLine; }
            <IDENTIFIER> { name = token.image; } 
            params = formalParameters() 
            ( 
                body = block() | 
                <SEMI> 
            )
            { 
                memberDecl = 
                   new JMethodDeclaration( line, mods, name, 
                                           type, params, body ); 
            } 
        ) | 
        ( 
            type = type() { line = token.beginLine; }
            variableDeclarators = variableDeclarators( type )
            <SEMI>
            { 
                memberDecl = new JFieldDeclaration( line, mods, 
                    variableDeclarators ); 
            }
        )
    } 
    catch ( ParseException e ) { 
        recoverFromError( new int[] { SEMI, EOF }, e ); 
    }
    { return memberDecl; }
}

/**
 * Parse a block.
 * 
 * <pre>
 *   block ::= LCURLY {blockStatement} RCURLY 
 * </pre>
 * 
 * @return an AST for a block.
 */

private JBlock block(): {
    int line = 0;
    JStatement aStatement = null;
    ArrayList<JStatement> statements = new ArrayList<JStatement>();
}
{
    try {
        <LCURLY> { line = token.beginLine; } 
        (
            aStatement = blockStatement()
            { statements.add( aStatement ); }
        )*
        <RCURLY>
    } 
    catch ( ParseException e ) { 
        recoverFromError( new int[] { SEMI, EOF }, e ); 
    }   
    { return new JBlock( line, statements ); }
}

/**
 * Parse a block statement.
 * 
 * <pre>
 *   blockStatement ::= localVariableDeclarationStatement
 *                    | statement
 * </pre>
 * 
 * @return an AST for a blockStatement.
 */

private JStatement blockStatement(): {
    JStatement statement = null;
}
{       
    try {
        LOOKAHEAD( type() <IDENTIFIER> )
        statement = localVariableDeclarationStatement() |
        statement =  statement() 
    } 
    catch ( ParseException e ) { 
        recoverFromError( new int[] { SEMI, EOF }, e ); 
    }   
    { return statement; }
}

/**
 * Parse a statement.
 * 
 * <pre>
 *   statement ::= block
 *               | IF parExpression statement [ELSE statement]
 *               | WHILE parExpression statement 
 *               | RETURN [expression] SEMI
 *               | SEMI 
 *               | statementExpression SEMI
 * </pre>
 * 
 * @return an AST for a statement.
 */

private JStatement statement(): {
    int line = 0;
    JStatement statement = null;
    JExpression test = null;
    JStatement consequent = null;
    JStatement alternate = null;
    JStatement body = null;
    JExpression expr = null;
}
{       
    try {
        statement = block() |
        <IF> { line = token.beginLine; }
        test = parExpression() 
        consequent = statement() 

        // Even without the lookahead below, which is added to 
        // suppress JavaCC warnings, dangling if-else problem is 
        // resolved by binding the alternate to the closest 
        // consequent.
        [ 
            LOOKAHEAD( <ELSE> ) 
            <ELSE> alternate = statement() 
        ]
        { statement = 
            new JIfStatement( line, test, consequent, alternate ); } |
        <WHILE> { line = token.beginLine; }
        test = parExpression() 
        body = statement()
        { statement = new JWhileStatement( line, test, body ); } |
        <RETURN> { line = token.beginLine; }
        [ 
            expr = expression() 
        ] 
        <SEMI>
        { statement = new JReturnStatement( line, expr ); } |
        <SEMI> 
        { statement = new JEmptyStatement( line ); } |
        // Must be a statementExpression
        statement = statementExpression() 
        <SEMI>
    } 
    catch ( ParseException e ) { 
        recoverFromError( new int[] { SEMI, EOF }, e ); 
    }
    { return statement; }
}

/**
 * Parse formal parameters.
 * 
 * <pre>
 *   formalParameters ::= LPAREN 
 *                          [formalParameter 
 *                            {COMMA  formalParameter}]
 *                        RPAREN
 * </pre>
 * 
 * @return a list of formal parameters.
 */

private ArrayList<JFormalParameter> formalParameters(): {
    ArrayList<JFormalParameter> parameters = 
        new ArrayList<JFormalParameter>();
    JFormalParameter aParameter = null;
}
{
    try {
        <LPAREN>
        [ 
            aParameter = formalParameter()
            { parameters.add( aParameter ); }
            ( 
                <COMMA> aParameter = formalParameter()
                { parameters.add( aParameter ); }
            )* 
        ]
        <RPAREN>
    } 
    catch ( ParseException e ) { 
        recoverFromError( new int[] { SEMI, EOF }, e ); 
    }
    { return parameters; }
}

/**
 * Parse a formal parameter.
 * 
 * <pre>
 *   formalParameter ::= type IDENTIFIER
 * </pre>
 * 
 * @return an AST for a formalParameter.
 */

private JFormalParameter formalParameter(): {
    int line = 0;
    Type type = null;
    String name = "";
}
{
    try {
        type = type() { line = token.beginLine; }
        <IDENTIFIER> { name = token.image; }
    } 
    catch ( ParseException e ) { 
        recoverFromError( new int[] { SEMI, EOF }, e ); 
    }
    { return new JFormalParameter( line, name, type ); }
}

/**
 * Parse a parenthesized expression.
 * 
 * <pre>
 *   parExpression ::= LPAREN expression RPAREN
 * </pre>
 * 
 * @return an AST for a parExpression.
 */

private JExpression parExpression(): {
    JExpression expr = null;

}
{
    try {
        <LPAREN> expr = expression() <RPAREN>
    } 
    catch ( ParseException e ) { 
        recoverFromError( new int[] { SEMI, EOF }, e ); 
    }   
    { return expr; }
}

/**
 * Parse a local variable declaration statement.
 * 
 * <pre>
 *   localVariableDeclarationStatement ::= type 
 *                                           variableDeclarators 
 *                                             SEMI
 * </pre>
 * 
 * @return an AST for a variableDeclaration.
 */

private JVariableDeclaration localVariableDeclarationStatement(): {
    int line = 0;
    Type type = null;
    ArrayList<JVariableDeclarator> vdecls = null;
    ArrayList<String> mods = new ArrayList<String>();
}
{
    try {
        type = type() { line = token.beginLine; }
        vdecls = variableDeclarators( type ) <SEMI>
    } 
    catch ( ParseException e ) { 
        recoverFromError( new int[] { SEMI, EOF }, e ); 
    }   
    { return new JVariableDeclaration( line, mods, vdecls ); }
}

/**
 * Parse variable declarators.
 * 
 * <pre>
 *   variableDeclarators ::= variableDeclarator 
 *                             {COMMA variableDeclarator}
 * </pre>
 * 
 * @param type type of the variables.
 * @return a list of variable declarators.
 */

private ArrayList<JVariableDeclarator> 
    variableDeclarators( Type type ): {
    JVariableDeclarator aVariableDeclarator = null;
    ArrayList<JVariableDeclarator> variableDeclarators =
        new ArrayList<JVariableDeclarator>();
}
{
    try {
        aVariableDeclarator = variableDeclarator( type )
        { variableDeclarators.add( aVariableDeclarator ); }
        (
            <COMMA> aVariableDeclarator = variableDeclarator( type )
            { variableDeclarators.add( aVariableDeclarator ); }
        )*
    } 
    catch ( ParseException e ) { 
        recoverFromError( new int[] { SEMI, EOF }, e ); 
    }
    { return variableDeclarators; }
}

/**
 * Parse a variable declarator.
 * 
 * <pre>
 *   variableDeclarator ::= IDENTIFIER
 *                          [ASSIGN variableInitializer]
 * </pre>
 * 
 * @param type type of the variable.
 * @return an AST for a variableDeclarator.
 */

private JVariableDeclarator variableDeclarator( Type type ): {
    int line = 0;
    JExpression initial = null;
    String name = "";
}
{
    try {
        <IDENTIFIER> { line = token.beginLine; name = token.image; }
        [ 
            <ASSIGN> initial = variableInitializer( type ) 
        ]
    } 
    catch ( ParseException e ) { 
        recoverFromError( new int[] { SEMI, EOF }, e ); 
    }   
    { return new JVariableDeclarator( line, name, type, initial ); }
}

/**
 * Parse a variable initializer.
 * 
 * <pre>
 *   variableInitializer ::= arrayInitializer
 *                         | expression
 * </pre>
 * 
 * @param type type of the variable.
 * @return an AST for a variableInitializer.
 */

private JExpression variableInitializer( Type expected ): {
    JExpression initializer = null;
}
{
    try {
        initializer = arrayInitializer( expected ) |
        initializer = expression()
    } 
    catch ( ParseException e ) { 
        recoverFromError( new int[] { SEMI, EOF }, e ); 
    }   
    { return initializer; }
}

/**
 * Parse an array initializer.
 * 
 * <pre>
 *   arrayInitializer ::= LCURLY 
 *                          [variableInitializer 
 *                            {COMMA variableInitializer} [COMMA]]
 *                        RCURLY 
 * </pre>
 * 
 * @param type type of the array.
 * @return an AST for an arrayInitializer.
 */

private JArrayInitializer arrayInitializer( Type expected ): {
    int line = 0; 
    ArrayList<JExpression> initials = new ArrayList<JExpression>();
    JExpression anInitializer = null;
}
{
    try {
        <LCURLY> { line = token.beginLine; }
        [ 
            anInitializer = 
              variableInitializer( expected.componentType() ) 
            { initials.add( anInitializer ); }
            ( 
                <COMMA> anInitializer = 
                    variableInitializer( expected.componentType() ) 
                { initials.add( anInitializer ); } 
            )* 
        ] 
        <RCURLY>
    } 
    catch ( ParseException e ) { 
        recoverFromError( new int[] { SEMI, EOF }, e ); 
    }
    { return new JArrayInitializer( line, expected, initials ); }
}

/**
 * Parse arguments.
 * 
 * <pre>
 *   arguments ::= LPAREN [expression {COMMA expression}] RPAREN    
 * </pre>
 * 
 * @return a list of expressions.
 */

private ArrayList<JExpression> arguments(): {
    ArrayList<JExpression> args = new ArrayList<JExpression>();
    JExpression anExpression = null;
}
{
    try {
        <LPAREN>
        [ 
            anExpression = expression() { args.add( anExpression ); } 
            ( 
                <COMMA> anExpression = expression() 
                { args.add( anExpression ); } 
            )*
        ] 
        <RPAREN>
    } 
    catch ( ParseException e ) { 
        recoverFromError( new int[] { SEMI, EOF }, e ); 
    }
    { return args; }
}

/**
 * Parse a type.
 * 
 * <pre>
 *   type ::= referenceType 
 *          | basicType
 * </pre>
 * 
 * @return an instance of Type.
 */
     
private Type type(): {
    Type type = null;
}
{
    try {
        LOOKAHEAD( <IDENTIFIER> | basicType() <LBRACK> <RBRACK> )
        type = referenceType() |
        type = basicType()
    } 
    catch ( ParseException e ) { 
       recoverFromError( new int[] { SEMI, EOF }, e ); 
    }
    { return type; }
}

/**
 * Parse a basic type.
 * 
 * <pre>
 *   basicType ::= BOOLEAN | CHAR | INT
 * </pre>
 * 
 * @return an instance of Type.
 */

private Type basicType(): {
    Type type = Type.ANY;
}
{
    try {
        <BOOLEAN> { type = Type.BOOLEAN; } |
        <CHAR> { type = Type.CHAR; } |
        <INT> { type = Type.INT; }
    } 
    catch ( ParseException e ) { 
        recoverFromError( new int[] { SEMI, EOF }, e ); 
    }
    { return type; }
}

/**
 * Parse a reference type.
 * 
 * <pre>
 *   referenceType ::= basicType LBRACK RBRACK {LBRACK RBRACK}
 *                   | qualifiedIdentifier {LBRACK RBRACK}
 * </pre>
 * 
 * @return an instance of Type.
 */

private Type referenceType(): {
    Type type = Type.ANY;
}
{
    try {
        type = basicType()
        <LBRACK> <RBRACK> { type = new ArrayTypeName( type ); }
        ( 
            <LBRACK> <RBRACK> 
            { type = new ArrayTypeName( type ); } 
        )* |
        type = qualifiedIdentifier()
        ( 
            <LBRACK> <RBRACK> 
            { type = new ArrayTypeName( type ); } 
        )*
    } 
    catch ( ParseException e ) { 
        recoverFromError( new int[] { SEMI, EOF }, e ); 
    }
    { return type; }       
}

/**
 * Parse a statement expression. 
 * 
 * <pre>
 *   statementExpression ::= expression // but must have 
 *                                      // side-effect, eg i++
 * </pre>
 * 
 * @return an AST for a statementExpression.
 */

private JStatement statementExpression(): {
    int line = 0;
    JExpression expr = null;
}
{
    try {
        expr = expression()
        {
            line = expr.line();
            if ( expr instanceof JAssignment
              || expr instanceof JPreIncrementOp
              || expr instanceof JPostDecrementOp
              || expr instanceof JMessageExpression
              || expr instanceof JSuperConstruction
              || expr instanceof JThisConstruction 
              || expr instanceof JNewOp
              || expr instanceof JNewArrayOp ) {
                // So as not to save on stack
                expr.isStatementExpression = true;
            }
            else {
                reportParserError( "Invalid statement expression; " + 
                    "it does not have a side-effect" );
            }
        }
    } 
    catch ( ParseException e ) { 
        recoverFromError( new int[] { SEMI, EOF }, e ); 
    }
    { return new JStatementExpression( line, expr ); }
}

/**
 * An expression.
 * 
 * <pre>
 *   expression ::= assignmentExpression 
 * </pre>
 * 
 * @return an AST for an expression.
 */

private JExpression expression(): {
    JExpression expr = null;
}
{
    try {
        expr = assignmentExpression()
    } 
    catch ( ParseException e ) { 
        recoverFromError( new int[] { SEMI, EOF }, e ); 
    }
    { return expr; }
}

/**
 * Parse an assignment expression.
 * 
 * <pre>
 *   assignmentExpression ::= 
 *       conditionalAndExpression // level 13
 *           [( ASSIGN  // conditionalExpression
 *            | PLUS_ASSIGN // must be valid lhs
 *            )
 *            assignmentExpression]
 * </pre>
 * 
 * @return an AST for an assignmentExpression.
 */

private JExpression assignmentExpression(): {
    int line = 0;
    JExpression lhs = null, rhs = null;
}
{
    try {
        lhs = conditionalAndExpression() { line = lhs.line(); }
        [       
            <ASSIGN> 
            rhs = assignmentExpression()
            { lhs = new JAssignOp( line, lhs, rhs ); } |
            <PLUS_ASSIGN>
            rhs = assignmentExpression()
            { lhs = new JPlusAssignOp( line, lhs, rhs ); }
        ]
    } 
    catch ( ParseException e ) { 
        recoverFromError( new int[] { SEMI, EOF }, e ); 
    }
    { return lhs; }
}

/**
 * Parse a conditional-and expression.
 * 
 * <pre>
 *   conditionalAndExpression ::= equalityExpression // level 10
 *                                  {LAND equalityExpression}
 * </pre>
 * 
 * @return an AST for a conditionalExpression.
 */

private JExpression conditionalAndExpression(): {
    int line = 0;
    JExpression lhs = null, rhs = null;
}
{
    try {
        lhs = equalityExpression() { line = lhs.line(); }
        ( 
            <LAND>
            rhs = equalityExpression()
            { lhs = new JLogicalAndOp( line, lhs, rhs ); }
        )*
    } 
    catch ( ParseException e ) { 
        recoverFromError( new int[] { SEMI, EOF }, e ); 
    }
    { return lhs; }
}

/**
 * Parse an equality expression.
 * 
 * <pre>
 *   equalityExpression ::= relationalExpression  // level 6
 *                            {EQUAL relationalExpression}
 * </pre>
 * 
 * @return an AST for an equalityExpression.
 */

private JExpression equalityExpression(): {
    int line = 0;
    JExpression lhs = null, rhs = null;
}
{
    try {
        lhs = relationalExpression() { line = lhs.line(); }
        ( 
            <EQUAL> 
            rhs = relationalExpression()
            { lhs = new JEqualOp( line, lhs, rhs ); }
        )*
    } 
    catch ( ParseException e ) { 
        recoverFromError( new int[] { SEMI, EOF }, e ); 
    }
    { return lhs; }
}

/**
 * Parse a relational expression.
 * 
 * <pre>
 *   relationalExpression ::= additiveExpression  // level 5
 *                              [(GT | LE) additiveExpression 
 *                              | INSTANCEOF referenceType]
 * </pre>
 * 
 * @return an AST for a relationalExpression.
 */

private JExpression relationalExpression(): {
    int line = 0;
    JExpression lhs = null, rhs = null;
    Type type = null;
}
{
    try {
        lhs = additiveExpression() { line = lhs.line(); }
        [ 
            <GT> 
            rhs = additiveExpression()
            { lhs = new JGreaterThanOp( line, lhs, rhs ); } |
            <LE> 
            rhs = additiveExpression()
            { lhs = new JLessEqualOp( line, lhs, rhs ); } |
            <INSTANCEOF> 
            type = referenceType()
            { lhs = new JInstanceOfOp( line, lhs, type ); }
        ]
    } 
    catch ( ParseException e ) { 
        recoverFromError( new int[] { SEMI, EOF }, e ); 
    }
    { return lhs; }
}

/**
 * Parse an additive expression.
 * 
 * <pre>
 *   additiveExpression ::= multiplicativeExpression // level 3
 *                            {MINUS multiplicativeExpression}
 * </pre>
 * 
 * @return an AST for an additiveExpression.
 */

private JExpression additiveExpression(): {
    int line = 0;
    JExpression lhs = null, rhs = null;
}
{
    try {
        lhs = multiplicativeExpression() { line = lhs.line(); } 
        ( 
            <PLUS> 
            rhs = multiplicativeExpression()
            { lhs = new JPlusOp( line, lhs, rhs ); } |
            <MINUS> 
            rhs = multiplicativeExpression()
            { lhs = new JSubtractOp( line, lhs, rhs ); }
        )*
    } 
    catch ( ParseException e ) { 
        recoverFromError( new int[] { SEMI, EOF }, e ); 
    }
    { return lhs; }
}

/**
 * Parse a multiplicative expression.
 * 
 * <pre>
 *   multiplicativeExpression ::= unaryExpression  // level 2
 *                                  {STAR unaryExpression}
 * </pre>
 * 
 * @return an AST for a multiplicativeExpression.
 */

private JExpression multiplicativeExpression(): {
    int line = 0;
    JExpression lhs = null, rhs = null;
}
{
    try {
        lhs = unaryExpression() { line = lhs.line(); }
        ( 
            <STAR> 
            rhs = unaryExpression()
            { lhs = new JMultiplyOp( line, lhs, rhs ); }
        )*
    } 
    catch ( ParseException e ) { 
        recoverFromError( new int[] { SEMI, EOF }, e ); 
    }
    { return lhs; }
}

/**
 * Parse an unary expression.
 * 
 * <pre>
 *   unaryExpression ::= INC unaryExpression // level 1
 *                     | MINUS unaryExpression
 *                     | simpleUnaryExpression
 * </pre>
 * 
 * @return an AST for an unaryExpression.
 */

private JExpression unaryExpression(): {
    int line = 0;
    JExpression expr = null, unaryExpr = null;
}
{
    try {
        <INC> { line = token.beginLine; }
        unaryExpr = unaryExpression()
        { expr = new JPreIncrementOp( line, unaryExpr ); } | 
        <MINUS> { line = token.beginLine; }
        unaryExpr = unaryExpression()
        { expr = new JNegateOp( line, unaryExpr ); } |
        expr = simpleUnaryExpression()
    } 
    catch ( ParseException e ) { 
        recoverFromError( new int[] { SEMI, EOF }, e ); 
    }
    { return expr; }
}

/**
 * Parse a simple unary expression.
 * 
 * <pre>
 *   simpleUnaryExpression ::= LNOT unaryExpression
 *                           | LPAREN basicType RPAREN 
 *                               unaryExpression
 *                           | LPAREN         
 *                               referenceType
 *                             RPAREN simpleUnaryExpression
 *                           | postfixExpression
 * </pre>
 * 
 * @return an AST for a simpleUnaryExpression.
 */

private JExpression simpleUnaryExpression(): {
    int line = 0;
    Type type = null;
    JExpression expr = null, unaryExpr = null, simpleUnaryExpr = null;
}
{
    try {
        <LNOT> { line = token.beginLine; }
        unaryExpr = unaryExpression()
        { expr = new JLogicalNotOp( line, unaryExpr ); } |
        LOOKAHEAD( <LPAREN> basicType() <RPAREN> )
        <LPAREN> { line = token.beginLine; }
        type = basicType() 
        <RPAREN>
        unaryExpr = unaryExpression()
        { expr = new JCastOp( line, type, unaryExpr ); } |
        LOOKAHEAD( <LPAREN> referenceType() <RPAREN> )
        <LPAREN> { line = token.beginLine; }
        type = referenceType() 
        <RPAREN>
        simpleUnaryExpr = simpleUnaryExpression()
        { expr = new JCastOp( line, type, simpleUnaryExpr ); } | 
        expr = postfixExpression() 
    } 
    catch ( ParseException e ) { 
        recoverFromError( new int[] { SEMI, EOF }, e ); 
    }
    { return expr ; }
}

/**
 * Parse a postfix expression.
 * 
 * <pre>
 *   postfixExpression ::= primary {selector} {DEC}
 * </pre>
 * 
 * @return an AST for a postfixExpression.
 */

private JExpression postfixExpression(): {
    int line = 0; 
    JExpression primaryExpr = null;
}
{
    try {
        primaryExpr = primary() { line = primaryExpr.line(); } 
        (
            primaryExpr = selector( primaryExpr ) 
        )*
        ( 
            <DEC> 
            { primaryExpr = 
                new JPostDecrementOp( line, primaryExpr ); } 
        )*
    } 
    catch ( ParseException e ) {
        recoverFromError( new int[] { SEMI, EOF }, e ); 
    }
    { return primaryExpr; }
}

/**
 * Parse a selector.
 * 
 * <pre>
 *   selector ::= DOT qualifiedIdentifier [arguments]
 *              | LBRACK expression RBRACK
 * </pre>
 * 
 * @param target the target expression for this selector.
 * @return an AST for a selector.
 */

private JExpression selector( JExpression target ): {       
    int line = 0;
    ArrayList<JExpression> args = null;
    TypeName id = null;
    JExpression expr = null;
}
{
    try {
        <DOT> { line = token.beginLine; } 
        id = qualifiedIdentifier()
        { expr = 
              new JFieldSelection( line, ambiguousPart( id ),
                                   target, id.simpleName() ); }
        [ 
            args = arguments() 
            { expr = new JMessageExpression( line, target, 
                  ambiguousPart( id ), id.simpleName(), args ); 
            } 
        ] |
        <LBRACK> { line = token.beginLine; }
        { expr = new JArrayExpression( line, target, expression() ); } 
        <RBRACK> 
    } 
    catch ( ParseException e ) { 
        recoverFromError( new int[] { SEMI, EOF }, e ); 
    }
    { return expr; }
}

/**
 * Parse a primary expression.
 * 
 * <pre>
 *   primary ::= parExpression
 *             | THIS [arguments]
 *             | SUPER ( arguments 
 *                     | DOT IDENTIFIER [arguments] 
 *                     )
 *             | literal
 *             | NEW creator
 *             | qualifiedIdentifier [arguments]
 * </pre>
 * 
 * @return an AST for a primary.
 */

private JExpression primary(): {
    int line = 0;
    JExpression expr = null;
    JExpression newTarget = null;
    ArrayList<JExpression> args = null;
    TypeName id = null;
}
{
    try {
        expr = parExpression() |
        <THIS> { line = token.beginLine; expr = new JThis( line ); }
        [ 
            args = arguments() 
            { expr = new JThisConstruction( line, args ); } 
        ] |
        <SUPER> { line = token.beginLine; }
        ( 
            args = arguments() 
            { expr = new JSuperConstruction( line, args ); } | 
            <DOT> <IDENTIFIER> 
            { 
                newTarget = new JSuper( line );
                expr = new JFieldSelection( line, newTarget, 
                                            token.image );
            }
            [ 
                args = arguments() 
                { expr = new JMessageExpression( line, newTarget, 
                      null, token.image, args ); }
            ] 
        ) |
        expr = literal() |
        <NEW> expr = creator() |

        // Language is ambiguous here. JavaCC warns about not being 
        // able to choose between qualifiedIdentifier and selector. 
        // Semantic analysis will sort it out.
        id = qualifiedIdentifier() 
        { 
            line = id.line(); 
            if ( ambiguousPart( id ) == null ) {
                expr = new JVariable( line, id.simpleName() );
            }
            else {
                expr = new JFieldSelection( line, ambiguousPart( id ), 
                                            null, id.simpleName() );             
            }
        } 
        [
            args = arguments()
            { expr = new JMessageExpression( line, null, 
                  ambiguousPart( id ), id.simpleName(), args ); }
        ]
    } 
    catch ( ParseException e ) { 
        recoverFromError( new int[] { SEMI, EOF }, e ); 
    }
    { return expr; }
}

/**
 * Parse a creator.
 * 
 * <pre>
 *   creator ::= (basicType | qualifiedIdentifier) 
 *                 ( arguments
 *                 | LBRACK RBRACK {LBRACK RBRACK} 
 *                     [arrayInitializer]
 *                 | newArrayDeclarator
 *                 )
 * </pre>
 * 
 * @return an AST for a creator.
 */

private JExpression creator(): {
    int line = 0;
    Type type = null;
    ArrayList<JExpression> args = null;
    ArrayList<JExpression> dims = null;
    JArrayInitializer init =  null;
    JExpression expr = null;
    Type expected = null;
}
{
    try {
        ( type = basicType() |
          type = qualifiedIdentifier() )
        { line = token.beginLine; expected = type; }
        (
            args = arguments()
            { expr = new JNewOp( line, type, args ); } |
            LOOKAHEAD( <LBRACK> expression() <RBRACK> )
            expr = newArrayDeclarator( type ) |
            <LBRACK> <RBRACK> { expected = new ArrayTypeName( expected
    ); }
            (
                LOOKAHEAD( <LBRACK> <RBRACK> )
                <LBRACK> <RBRACK>
                { expected = new ArrayTypeName( expected ); }
            )*
            [
               expr = arrayInitializer( expected )
            ]
        )
    }
    catch ( ParseException e ) {
        expr = new JWildExpression( token.beginLine );
        recoverFromError( new int[] { SEMI, EOF }, e );
    }
    { return expr; }
}

/**
 * Parse a new array declarator.
 * 
 * <pre>
 *   newArrayDeclarator ::= LBRACK expression RBRACK 
 *                            {LBRACK expression RBRACK}
 *                            {LBRACK RBRACK}
 * </pre>
 * 
 * @param line line in which the declarator occurred.
 * @param type type of the array.
 * @return an AST for a newArrayDeclarator.
 */

private JNewArrayOp newArrayDeclarator( Type type ): {
    int line = 0;
    ArrayList<JExpression> dimensions = new ArrayList<JExpression>();
    JExpression expr = null;
}
{
    try {
        <LBRACK> { line = token.beginLine; } 
        expr = expression() 
        { dimensions.add( expr ); type = new ArrayTypeName( type ); }
        <RBRACK>
        ( 
            LOOKAHEAD( <LBRACK> expression() <RBRACK> )
            <LBRACK> 
            expr = expression() 
            { dimensions.add( expr); type = new ArrayTypeName( type ); } 
            <RBRACK> 
        )*
        (
            LOOKAHEAD( <LBRACK> <RBRACK> )
            <LBRACK> <RBRACK> { type = new ArrayTypeName( type ); }
        )*
    } 
    catch ( ParseException e ) {
        recoverFromError( new int[] { SEMI, EOF }, e ); 
    }
    { return new JNewArrayOp( line, type, dimensions ); }
}

/**
 * Parse a literal.
 * 
 * <pre>
 *   literal ::= INT_LITERAL | CHAR_LITERAL | STRING_LITERAL
 *             | TRUE        | FALSE        | NULL
 * </pre>
 * 
 * @return an AST for a literal.
 */

private JExpression literal(): {
    JExpression expr = null;
}
{       
    try {
        <INT_LITERAL> 
        { expr = new JLiteralInt( token.beginLine, token.image ); } | 
        <CHAR_LITERAL> 
        { expr = new JLiteralChar( token.beginLine, token.image ); } |
        <STRING_LITERAL> 
        { expr = 
              new JLiteralString( token.beginLine, token.image ); } | 
        <TRUE> 
        { expr = new JLiteralTrue( token.beginLine ); } | 
        <FALSE> 
        { expr = new JLiteralFalse( token.beginLine ); } |
        <NULL> 
        { expr = new JLiteralNull( token.beginLine ); }
    } 
    catch ( ParseException e ) { 
        expr = new JWildExpression( token.beginLine ); 
        recoverFromError( new int[] { SEMI, EOF }, e ); 
    }
    { return expr; }
}
